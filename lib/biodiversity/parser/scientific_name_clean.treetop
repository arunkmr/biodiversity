# encoding: UTF-8
grammar ScientificNameClean

  rule scientific_name
    multinomial_name
    /
    uninomial_name
  end
  
  rule multinomial_name
    a:genus space b:subgenus space c:species space_hard d:infraspecies {
      def value
        a.value + " " + b.value + " " + c.value + " " + d.value
      end
    
      def canonical
        a.canonical + " " + c.canonical + " " + d.canonical
      end
    
      def pos
        a.pos.merge(b.pos).merge(c.pos).merge(d.pos)
      end
    
      def details
        a.details.merge(b.details).merge(c.details).merge(d.details)
      end
    }
    /  
    a:genus space b:subgenus space c:species {
      def value
        a.value + " " + b.value + " " + c.value
      end
      
      def canonical
        a.canonical + " " + c.canonical
      end
      
      def pos
        a.pos.merge(b.pos).merge(c.pos)
      end
      
      def details
        a.details.merge(b.details).merge(c.details)
      end
    }
    /
    a:genus space_hard b:species space_hard c:infraspecies {
      def value
        a.value + " " + b.value + " " + c.value 
      end

      def canonical
        a.canonical + " " + b.canonical + " " + c.canonical
      end
    
      def pos
        a.pos.merge(b.pos).merge(c.pos)
      end
    
      def details
        a.details.merge(b.details).merge(c.details)
      end
    }
    /
    a:genus space_hard b:species {
      def value
        a.value + " " + b.value 
      end

      def canonical
        a.canonical + " " + b.canonical
      end
      
      def pos
        a.pos.merge(b.pos)
      end
      
      def details
        a.details.merge(b.details)
      end
    }
  end
  
  rule infraspecies
    a:infraspecies_epitheton space b:authorship {
      def value
        a.value + " " + b.value
      end
  
      def canonical
        a.canonical
      end
  
      def pos
        a.pos.merge(b.pos)
      end
  
      def details
        {:infraspecies => a.details[:infraspecies].merge(b.details)}
      end
    }
    /
    infraspecies_epitheton
  end
  
  rule infraspecies_epitheton
    latin_word ![\.] {
      def value
        text_value
      end
      
      def canonical
        value
      end
  
      def pos
        {interval.begin => ['infraspecies', interval.end]}
      end
  
      def details
        {:infraspecies => {:epitheton => value, :rank => 'n/a'}}
      end
    }
  end
  
  
  rule species
    a:species_epitheton space b:authorship {
      def value
        a.value + " " + b.value
      end
      
      def canonical
        a.canonical
      end
      
      def pos
        a.pos.merge(b.pos)
      end
      
      def details
        {:species => a.details[:species].merge(b.details)}
      end
    }
    /
    species_epitheton
  end
  
  rule species_epitheton
    latin_word {
      def canonical
        value
      end
    
      def pos
        {interval.begin => ['species', interval.end]}
      end
    
      def details
        {:species => {:epitheton => value}}
      end
    }
  end
  
  rule subgenus
    "(" space a:cap_latin_word space ")" {
      def value
        "(" + a.value + ")"
      end
      
      def pos
        {a.interval.begin => ['subgenus', a.interval.end]}
      end
      
      def details
        {:subgenus => {:epitheton => a.value}}
      end
    }
  end
  
  rule genus
    cap_latin_word {
      def pos
        {interval.begin => ['genus', interval.end]}
      end
      
      def canonical
        value
      end
          
      def details
        {:genus => {:epitheton => value}}
      end
    }
  end
  
  rule uninomial_name
    a:uninomial_epitheton space_hard b:authorship {
      def value
        a.value + " " + b.value
      end
      
      def canonical
        a.canonical
      end
      
      def pos
        a.pos.merge(b.pos)
      end
      
      def details
        {:uninomial => a.details[:uninomial].merge(b.details)}
      end
    }
    /
    uninomial_epitheton
  end

  rule uninomial_epitheton
    cap_latin_word {
      def canonical
        value
      end
      
      def pos
        {interval.begin => ['uninomial', interval.end]}
      end
      
      def details 
        {:uninomial => {:epitheton => value}}
      end
    }
  end
  
  rule authorship
    a:basionym_authorship_with_parenthesis space b:simple_authorship {
      def value
        a.value + " " + b.value
      end
      
      def pos
        a.pos.merge(b.pos)
      end
      
      def details
        {:authorship => text_value, :combinationAuthorTeam => b.details_with_arg('combinationAuthorTeam')[:combinationAuthorTeam], :basionymAuthorTeam => a.details[:basionymAuthorTeam]}
      end
    }
    /
    basionym_authorship_with_parenthesis
    /
    simple_authorship
  end
   
  
  rule basionym_authorship_with_parenthesis
    "(" space a:authors_names space ")" space [,]? space b:year {
      def value
        "(" + a.value + " " + b.value + ")"
      end
      
      def pos
        a.pos.merge(b.pos)
      end 
      
      def details
        { :authorship => text_value, 
          :basionymAuthorTeam => {
            :authorTeam => a.text_value
          }.merge(a.details).merge(b.details)
        }      
      end    
    }
    /
    "(" space a:simple_authorship space ")" {
      def value
        "(" + a.value + ")"
      end
      
      def pos
        a.pos
      end
      
      def details
        val = a.details
        val[:authorship] = text_value
        val      
      end
    }
    /
    "(" space a:"?" space ")" {
      def value
        "(?)"
      end
      
      def pos
        {a.interval.begin => ['unknown_author', a.interval.end]}
      end
      
      def details
        {:authorship => text_value, :basionymAuthorTeam => {:authorTeam => text_value, :author => ['?']}}
      end
    }
  end

  rule simple_authorship
    a:authors_names space [,]? space b:year {
      def value
        a.value + " " + b.value
      end
      
      def pos
        a.pos.merge(b.pos)
      end
      
      def details
        details_with_arg(:basionymAuthorTeam)
      end
      
      def details_with_arg(authorTeamType = 'basionymAuthorTeam')
        { :authorship => text_value, 
          authorTeamType.to_sym => {
            :authorTeam => a.text_value.strip
          }.merge(a.details).merge(b.details)
        }
      end
    }
    /
    authors_names {
      def details
        details = details_with_arg(:basionymAuthorTeam)
        details[:basionymAuthorTeam].merge!(super)
        details
      end
      
      def details_with_arg(authorTeamType = 'basionymAuthorTeam')
        { :authorship => text_value, 
          authorTeamType.to_sym => {
            :authorTeam => text_value
          }
        }      
      end
    }
  end
  
  rule authors_names
    a:author_name space sep:author_separator space b:authors_names {
      def value
        sep.apply(a,b)
      end
      
      def pos
        sep.pos(a,b)
      end
      
      def details
        sep.details(a,b)
      end
    }
    /
    author_name
    /
    unknown_auth
  end
  
  
  rule unknown_auth
    ("auct."/"hort."/"anon."/"ht.") {
      def value
        text_value
      end
      
      def pos
       {interval.begin => ['unknown_author', interval.end]}
      end
      
      def details
        {:author => ["unknown"]}
      end
    }
  end
  
  
  
  rule author_separator
    ("&"/","/"and"/"et") {
      def apply(a,b)
        sep = text_value.strip
        sep = " et" if ["&","and","et"].include? sep
        a.value + sep + " " + b.value
      end
      
      def pos(a,b)
        a.pos.merge(b.pos)
      end
      
      def details(a,b)
        {:author => a.details[:author] + b.details[:author]}
      end
    }
  end
  
  rule author_name
    space a:author_word space b:author_name space {
      def value
        a.value + " " + b.value
      end
      
      def pos
        a.pos.merge(b.pos)
      end
      
      def details
        {:author => [value]}
      end
    }
    /
    author_word
  end
  
  rule author_word
    "A S. Xu" {
      def value
        text_value.strip
      end
      
      def pos
        {interval.begin => ['author_word', 1], (interval.begin + 2) => ['author_word', 2], (interval.begin + 5) => ['author_word', 2]}
      end
      
      def details
        {:author => [value]}
      end
    }
    /
    ("anon."/"f."/"bis"/"arg."/"da"/"der"/"den"/"de"/"du"/"la"/"ter"/"van"/"et al.\{\?\}"/"et al.") {
      def value
        text_value.strip
      end
      
      def pos
        #cheating because there are several words in some of them
        {interval.begin => ['author_word', interval.end]}
      end
      
      def details
        {:author => [value]}
      end
    }
    / 
    ("Å"/"Ö"/"Á"/"Ø"/"Ô"/"Š"/"Ś"/"Č"/"Ķ"/"Ł"/"É"/"Ž"/[A-Z]) [^0-9()\s&,]* {
      def value
        text_value
      end
      
      def pos
        {interval.begin => ['author_word', interval.end]}
      end
      
      def details
        {:author => [value]}
      end
    }
  end
  
  rule cap_latin_word
    a:([A-Z]/cap_digraph) b:latin_word "?" {
      def value
        (a.value rescue a.text_value) + b.value
      end
    }
    /
    a:([A-Z]/cap_digraph) b:latin_word {
      def value
        (a.value rescue a.text_value) + b.value
      end
    }
    /
    ("Ca"/"Ea"/"Ge"/"Ia"/"Io"/"Io"/"Ix"/"Lo"/"Oa"/"Ra"/"Ty"/"Ua"/"Aa"/"Ja"/"Zu"/"La"/"Qu"/"As"/"Ba") {
      def value
        text_value
      end
    }
  end

  rule latin_word
    a:[a-zëüäöïé] b:full_name_letters {
      def value
        a.text_value + b.value
      end
     }
     /
     a:digraph b:full_name_letters {
      def value
        a.value + b.value
      end
     }
  end

  rule full_name_letters
    a:digraph b:full_name_letters {
      def value
        a.value + b.value
      end
    }
    /
    a:valid_name_letters b:digraph c:full_name_letters {
      def value
        a.value + b.value + c.value
      end
    }
    /
    valid_name_letters
  end

  rule valid_name_letters
    [a-z\-ëüäöïé]+ {
      def value
        text_value
      end
    }
  end 

  rule cap_digraph
    "Æ" {
      def value
      'Ae'
      end
    }
    /
    "Œ" {
      def value
      'Oe'
      end
    }  
  end

  rule digraph
    "æ" {
      def value
      'ae'
      end
    }   
    /
    "œ" {
      def value
      'oe'
      end
    }
  end

  rule year
    year_number_with_character
    /
    year_number
  end

  rule year_number_with_character
    a:year_number [a-zA-Z] {
      def value
        a.text_value
      end

      def pos
        {interval.begin => ['year', interval.end]}
      end

      def details
        {:year => value}
      end
    }
  end
  
  rule year_number
    [12] [7890] [0-9] [0-9\?] {
      def value
        text_value
      end
      
      def pos
        {interval.begin => ['year', interval.end]}
      end
      
      def details
        {:year => value}
      end
    }
  end
  
  rule space
    [\s]*
  end

  rule space_hard
    [\s]+
  end
  
end